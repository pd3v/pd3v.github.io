<!DOCTYPE html>
<html>
<head>
  <style>
  body {
    width:  100%;
    height: 100%;
    margin: 0px;
  }
  #top_bar {
    margin: 0px;
  }
  #title {
    font-family: "menlo", sans-serif;
    font-size: 40px;
    color: cyan;
    float: left;
  }
  #version {
    height: 40px;
    font-family: "verdana", sans-serif;
    font-size: 14px;
    color: cyan;
    line-height: 65px;
    margin-left: 5px;
    float: left;
  }
  #subtitle {
    font-family: "menlo", sans-serif;
    font-size: 30px;
    color: #777777;
    margin-left: 15px;
    line-height: 60px;
    float: left;
  }
  canvas {
    position: absolute;
    z-index: -1;
  }
  </style>
  <title>pd3v sounding code</title>
  <meta charset="UTF-8">
</head>
<body>
  <script type="text/javascript" src="midiout.js"></script>
  <script type="text/javascript" src="synth.js"></script>
  <script type="text/javascript" src="generator.js"></script>
  <script type="text/javascript" src="sequencer.js"></script>
  <script type="text/javascript" src="helpers.js"></script>
  <canvas id="colorCanvas"></canvas>
  <div id="top_bar">
    <div id="title">fluX</div>
    <div id="version">0.0.1</div>
    <div id="subtitle">sounding</div>
  </div>
</body>
<script>
// Page layout
var canvas = document.getElementById("colorCanvas");
var ctx = canvas.getContext("2d");
ctx.canvas.width  = window.innerWidth;
ctx.canvas.height = window.innerHeight;

var AudioContext = window.AudioContext || window.webkitAudioContext;
var ac = new AudioContext();

var analyser = ac.createAnalyser();
var bufferLength = analyser.frequencyBinCount;
var dataArray = new Uint8Array(bufferLength);
var fps = 20;

analyser.fftSize = 2048;
analyser.getByteTimeDomainData(dataArray);

var audio = document.querySelector('audio');

if (navigator.mediaDevices) {
    navigator.mediaDevices.getUserMedia ({audio: true, video: false})
    .then(function(stream) {
        var source = ac.createMediaStreamSource(stream);
        source.connect(analyser);
    })
    .catch(function(err) {
        console.log(err);
    });
} else {
   console.log('getUserMedia not supported on your browser!');
}

let CMinorScale = {'c':0, 'd':2, 'ef':3, 'f':5, 'g':7, 'af':8, 'bb':10};
let CWholeScale = {'c':0, 'd':2, 'e':4, 'fs':6, 'g':8, 'a':10};
const scaleLength = Object.values(CMinorScale).length;
const scaleLength2 = Object.values(CWholeScale).length;

// generate a musical random mayhem of notes, velocity, duration and octaves!
// :)
/*const f = _ => {
  const octave = rand(0,6);

  return {
    note:rand()*(scaleLength-1),
    vel:rand(40,127),
    dur:2**rand(4,7),
    oct:octave != 1 ? octave : 3
  };
}

const g = _ => {
  return {
    note:countTo(2) == 0 ? countTo(scaleLength):countFrom(scaleLength),
    vel:countTo(6) < 3 ? linear(117,127,0,3,countTo(3)) : linear(127,117,0,3,countTo(3)),
    dur:countTo(200) < 175 ? 2**rand(4,6).toFixed(0) : 3,
    oct:countTo(50) < 25 ? countTo(3)+3: countFrom(2)+5
  };
}

const h = _ => {
  const scale = [0,10,2,8,4,6];
  const linearProg = linear(2,6,0,80,countTo(100));
  return {
    note:scale[linear(0,scaleLength2-1,0,scaleLength2-1,countTo(scaleLength2))],
    vel:127,
    dur:2**linearProg.toFixed(0),
    oct:linearProg.toFixed(0)
  };
}

const scaleC = [0,2,4,6,8,10];
const i = _ => {
  const scaleD = [1,3,5,7,9,11];
  const linearProg = linear(2,6,0,80,countTo(100));
  let ind = parseInt(linear(0,scaleC.length-1,0,scaleC.length-1,countTo(scaleC.length)).toFixed(0));
  console.log(scaleC[ind], ind);
  return {
    note:countTo(5),
    //scaleD[ind],
    //scaleC[linear(0,scaleC.length-1,0,scaleC.length-1,countTo(scaleC.length)).toFixed(0)],
    // scaleD[linear(0,scaleD.length-1,0,scaleD.length-1,countTo(scaleD.length))],
    //scale[linear(0,scaleLength2-1,0,scaleLength2-1,countTo(scaleLength2))],
    vel:127,
    dur:4,//2**linearProg.toFixed(0),
    oct:3//linearProg.toFixed(0)
  };
}*/

const simpleLinear = _ => {
  const d = [32,4,16,3];
  console.log('countTo(5)='+countTo(5));
  return {
    note:counter()%25 < 15 ? countTo(scaleLength2-1) : rand(scaleLength2-4,scaleLength2-1).toFixed(0),
    vel:linear(0,127).toFixed(0),
    dur:d[linear(0,3,50).toFixed(0)],
    oct:linear(2,6,100).toFixed(0)
  };
}

CMinorScale = {'c':0, 'd':2, 'ef':3, 'f':5, 'g':7, 'af':8, 'bb':10};
CWholeScale = {'c':0, 'd':2, 'e':4, 'fs':6, 'g':8, 'a':10};

// Melody with Markov Chains
const melody = scale => {
  let phrase = [];
  let phrasings = {};

	for (let i = 0; i < 20; i++){
    phrase.push(round(rand(0,Object.keys(scale).length-1)));
	}
  console.log(phrase);
  for (let j = 0; j < phrase.length-1; j++) {
    if (!phrasings[phrase[j]]) {
      phrasings[phrase[j]]=[];
    }
    phrasings[phrase[j]].push(phrase[j+1]);
  }
  return {phrasings, scale};
}

let melodyObj = melody(CMinorScale);
//let duration = 0;

random1 = phr => {
  return phr[round(rand(0,phr.length-1))];
}

foo = _ => {
  //console.log('melodyObj:'+melodyObj.phrasings[0], Object.keys(melodyObj.scale).length, countTo(4));
  //console.log('countTo(5)='+countTo(5));
  let note;
  let noteIndex;
  //console.log(countFrom(2));
  // Every 50 notes generate new phrasings
  if (counter()%50 == 49) {
      console.log('***** counter:'+counter()+' *****');
      melodyObj = melody(CMinorScale);
  }

  let phrasingToPlay = countTo((Object.keys(melodyObj.phrasings)).length-1);//countTo((Object.keys(melodyObj.scale)).length-1);
  /*if (!melodyObj.phrasings[phrasingToPlay]) {
    console.log("ahah:"+Object.keys(melodyObj.phrasings), round(Object.keys(melodyObj.phrasings).length-1));
    phrasingToPlay = round(Object.keys(melodyObj.phrasings).length-1);
  }*/
  console.log('ahah:'+Object.keys(melodyObj.phrasings), countTo((Object.keys(melodyObj.phrasings)).length-1));
  console.log('eheh:'+melodyObj.phrasings[countTo((Object.keys(melodyObj.phrasings)).length-1)]);
  let phrasing = melodyObj.phrasings[countTo((Object.keys(melodyObj.phrasings)).length-1)];//melodyObj.phrasings[phrasingToPlay];
  console.log('phrasing:'+phrasing, 'phrasingToPlay:'+phrasingToPlay);

  noteIndex = round(rand(0,phrasing.length-1))
  note = phrasing[noteIndex];

  let d = round((2**(phrasing.length)));
  let v = 127*(1-((noteIndex+1)/(phrasing.length))*0.5);
  let o = round(phrasing.reduce((accum, value)=>{
    accum += value;
    return accum;
  })/phrasing.length);

  console.log(`melody:${JSON.stringify(melodyObj)}`);
  //console.log(`phrasings:${phrasingToPlay} phrasing:${phrasing} phrasing lenght:${phrasing.length} note index:${noteIndex}`);
  //console.log(`phrasing:${phrasing} phrasing lenght:${phrasing.length} phrasing to vel:${127*(noteIndex+1)/phrasing.length} note index:${noteIndex}`);
  // console.log(`phrasing n:${phrasingToPlay} note:${note} vel:${vel} dur:${duration} oct:${round(octave/phrasing.length)}`);
  console.log(`phrasing n:${phrasingToPlay} note:${note}<->${note+(o*12)} vel:${v} dur:${d} oct:${o}`);
  //console.log(`note:${note}`);
  return {
    // randoms note from phrasing
    note:phrasing[noteIndex],
    //the smaller the phrasing higer the note velocity
    vel:v,
    // the bigger the phrasing shorter the note's duration
    // dur:round((2**(phrasing.length+(countTo(60)<30 ? 1 : 0)))),
    dur:d,
    // averages by phrasing content
    oct:o
  }
}

Sequencer.generator(CMinorScale,foo).midiOut('midi port1').start(120);
// Sequencer.generator(CMinorScale,simpleLinear).midiOut('midi port1').start(120);
// Sequencer.generator(leScale,f).synth('Synth').start(120);

drawWave();

function drawWave() {
  var sliceWidth = ctx.canvas.width * 1.1 / bufferLength;
  var x = 0;

  analyser.getByteTimeDomainData(dataArray);

  ctx.lineWidth = 0.5;
  ctx.strokeStyle = '#FFFFFF';

  setTimeout(function() {
       requestAnimationFrame(drawWave);

       ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
       ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
       ctx.beginPath();

       for(var i = 0; i < bufferLength; i++) {
         var v = dataArray[i] / 128.0;
         var y = v * ctx.canvas.height/2;

         if(i === 0) {
           ctx.moveTo(x, y);
         } else {
           ctx.lineTo(x, y);
         }
         x += sliceWidth;
       }
   }, 1000 / fps);

  ctx.lineTo(ctx.canvas.width, ctx.canvas.height);
  ctx.stroke();
};
</script>
</html>
